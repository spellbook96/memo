[TOC]

# 一. C++基础

## 1\. C和C++有什么区别？

- C++是面向对象的语言，而C是面向过程的语言；
- C++引入new/delete运算符，取代了C中的malloc/free库函数；
- C++引入引用的概念，而C中没有；
- C++引入类的概念，而C中没有；
- C++引入函数重载的特性，而C中没有

## 2\. a和&a有什么区别？

假设数组int a\[10\]; int (*p)\[10\] = &a; 其中：

- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a\[1\]。
- &a是数组的指针，其类型为int (*)\[10\]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
- 若(int *)p ，此时输出 \*p时，其值为a\[0\]的值，因为被转为int \*类型，解引用时按照int类型大小来读取。

## 3\. static关键字有什么作用?

- **修饰局部变量时:**使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；
- **修饰全局变量时**:使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；
- **修饰函数时**:在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突；
- **修饰成员变量时**:所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加`static`；
- **修饰成员函数时**:该函数不接受`this`指针，只能访问类的静态成员；不需要实例化对象即可访问。

## 4\. #define和const有什么区别？

- **编译器处理方式不同：**`#define`宏是在预处理阶段展开，不能对宏定义进行调试，而`const`常量是在编译阶段使用；
- **类型和安全检查不同：**`#define`宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错误，而`const`常量有具体类型，在编译阶段会执行类型检查；
- **存储方式不同：**`#define`宏仅仅是代码展开，在多个地方进行字符串替换，不会分配内存，存储于程序的代码段中，而`const`常量会分配内存，但只维持一份拷贝，存储于程序的数据段中。
- **定义域不同：**`#define`宏不受定义域限制，而`const`常量只在定义域内有效。

## 5\. 静态链接和动态链接有什么区别？

- **静态链接**

  - 在编译链接时直接将需要的执行代码拷贝到调用处；

  - 优点在于程序在发布时不需要依赖库，可以独立执行，缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接；

- **动态链接**

  - 在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接；

  - **优点**在于多个程序可以共享同一个动态库，节省资源；

  - **缺点**在于由于运行时加载，可能影响程序的前期执行性能。

## 6\. 变量的声明和定义有什么区别?

变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个地方定义。加入`extern` 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。

> 很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。

```cpp
int main() 
{
   extern int A;
   //这是个声明而不是定义，声明A是一个已经定义了的外部变量
   //注意：声明外部变量时可以把变量类型去掉如：extern A;
   dosth(); //执行函数
}
int A; //是定义，定义了A为整型的外部变量
```

## 7\. 简述#ifdef、#else、#endif和#ifndef的作用

`#define`:定义一个预处理宏
`#undef`: 取消宏的定义

`#if` :编译预处理中的条件命令，相当于C语法中的if语句
`#ifdef`:判断某个宏是否被定义，若已定义，执行随后的语句
`#ifndef`:与`#ifdef`相反，判断某个宏是否未被定义
`#elif`:若`#if`, `#ifdef`, `#ifndef`或前面的`#elif`条件不满足，则执行`#elif`之后的语句，相当于C语法中的else-if
`#else`:与`#if`, `#ifdef`, `#ifndef`对应, 若这些条件不满足，则执行`#else`之后的语句，相当于C语法中的`else`
`#endif`: `#if`, `#ifdef`, `#ifndef`这些条件命令的结束标志.
`defined`:与`#if`, `#elif`配合使用，判断某个宏是否被定义



利用`#ifdef`、`#endif`将某程序功能模块包括进去，以向特定用户提供该功能。在不需要时用户可轻易将其屏蔽。

```cpp
#ifdef MATH
#include "math.c"
#endif
```

在子程序前加上标记，以便于追踪和调试。

```cpp
#ifdef DEBUG
printf ("Indebugging......!");
#endif
```

应对硬件的限制。由于一些具体应用环境的硬件不一样，限于条件，本地缺乏这种设备，只能绕过硬件，直接写出预期结果。

> 虽然不用条件编译命令而直接用if语句也能达到要求，但那样做目标程序长（因为所有语句都编译），运行时间长（因为在程序运行时间对if语句进行测试）。而采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间。

## 8\. 写出int 、bool、 float 、指针变量与 “零值”比较的if 语句

```cpp
//int与零值比较 
if ( n == 0 )
if ( n != 0 )

//bool与零值比较 
if   (flag) //   表示flag为真 
if   (!flag) //   表示flag为假 

//float与零值比较 
const float EPSINON = 0.00001;
if ((x >= - EPSINON) && (x <= EPSINON) //其中EPSINON是允许的误差（即精度）。
//指针变量与零值比较 
if (p == NULL)
if (p != NULL)
```

## 9. 结构体可以直接赋值吗?

声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时一定要小心。

> 当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放前一定要确保其他指针不再使用这段内存空间。

## 10. `sizeof` 和`strlen` 的区别

- `sizeof`是一个操作符，`strlen`是库函数。
- `sizeof`计算的是数据类型占内存的大小，而`strlen`计算的是字符串实际的长度。
- `sizeof`的参数可以是数据的类型，也可以是变量，而`strlen`只能以结尾为‘\0’的字符串作参数。
- 编译器在编译时就计算出了`sizeof`的结果，而`strlen`函数必须在运行时才能计算出来。
- 数组做`sizeof`的参数不退化，传递给`strlen`就退化为指针了

## 11. C 语言的关键字 static 和 C++ 的关键字 static 有什么区别?

在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。

> 编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。

## 12. volatile有什么作用?

- 状态寄存器一类的并行设备硬件寄存器。
- 一个中断服务子程序会访问到的非自动变量。
- 多线程间被几个任务共享的变量。

> 虽然volatile在嵌入式方面应用比较多，但是在PC软件的多线程中，volatile修饰的临界变量也是非常实用的。

## 13. 一个参数可以既是const又是volatile吗?

**可以**，用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。

> 在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没有实际地禁止某段内存的读写特性。

## 14. 全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？

- **全局变量**是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）；

- **局部变量**存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。

- **操作系统和编译器**，可能是通过内存分配的位置和名称来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。

  > 可以参考侯捷memo，每个同名变量对于编译器是不同名的。

## 15. 简述strcpy、sprintf 与memcpy 的区别

- **操作对象不同**，`strcpy` 的两个操作对象均为字符串，`sprintf` 的操作源对象可以是多种数据类型， 目的操作对象是字符串，`memcpy` 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。
- **执行效率不同**，`memcpy` 最高，`strcpy` 次之，`sprintf` 的效率最低。
- **实现功能不同**，`strcpy` 主要实现字符串变量间的拷贝，`sprintf` 主要实现其他数据类型格式到字 符串的转化，memcpy 主要是内存块间的拷贝。

> strcpy、sprintf 与memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来 选择合适的函数实现拷贝功能。

## 16. 对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？

应该使用`inline`内联函数，即编译器将`inline`内联函数内的代码替换到函数被调用的地方。

- 优点：
  - 在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率；
  - 相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全；

- 缺点：
  - 代码膨胀，产生更多的开销；
  - 如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大；
  - 如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译；
    - 内联声明只是建议，是否内联由编译器决定，所以实际并不可控。

## 17. 什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？

​	智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用`delete`删除指针所指向的内存空间。

​	智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。

​	分为`auto_ptr`、`unique_ptr`、`shared_ptr`和`weak_ptr`四种，各自的特点：

- `auto_ptr`  ，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但`auto_ptr`在C++11中被摒弃，其主要问题在于：
  - 对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；
  - 不能指向数组，也不能作为STL容器的成员。

- `unique_ptr`，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值；

- `shared_ptr`，实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源；

- `weak_ptr`，解决`shared_ptr`相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而`weak_ptr`是对对象的一种弱引用，可以绑定到`shared_ptr`，但不会增加对象的引用计数。

## 18. shared\_ptr是如何实现的？

1. 构造函数中计数初始化为1；
2. 拷贝构造函数中计数值加1；
3. 赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1；
4. 析构函数中引用计数减1；
5. 在赋值运算符和析构函数中，如果减1后为0，则调用`delete`释放对象。

## 19. 右值引用有什么作用？

​	右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数.

## 20. 悬挂指针与野指针有什么区别？

- **悬挂指针：**当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针；
- **野指针：**未初始化的指针被称为野指针。

## 21. 动态多态有什么作用？有哪些必要条件？

- **动态多态的作用：**
  - 隐藏实现细节，使代码模块化，提高代码的可复用性；
  - 接口重用，使派生类的功能可以被基类的指针/引用所调用，即向后兼容，提高代码的可扩充性和可维护性。

- **动态多态的必要条件：**
  - 需要有继承；
  - 需要有虚函数覆盖；
  - 需要有基类指针/引用指向子类对象。

## 22. 请解析`((void()( ) )0)( )`的含义

- void (*0)( ) ：是一个返回值为void，参数为空的函数指针0。
- (void (*)( ))0：把0转变成一个返回值为void，参数为空的函数指针。
- (void ()( ))0：在上句的基础上加*表示整个是一个返回值为void，无参数，并且起始地址为0的函数的名字。
- ((void ()( ))0)( )：这就是上句的函数名所对应的函数的调用。

## 23. C语言的指针和引用和c++的有什么区别？

- 指针有自己的一块空间，而引用只是一个别名；
- 使用`sizeof`看一个指针的大小是4，而引用则是被引用对象的大小；
- 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；
- 可以有`const`指针，但是没有`const`引用；
- 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
- 指针可以有多级指针`（**p）`，而引用止于一级；
- 指针和引用使用`++`运算符的意义不一样；
- 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

## 24. `typedef` 和`define` 有什么区别?

- **用法不同：**`typedef` 用来定义一种数据类型的别名，增强程序的可读性。`define` 主要用来定义 常量，以及书写复杂使用频繁的宏。
- 执行时间不同：`typedef` 是编译过程的一部分，有类型检查的功能。`define` 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。
- **作用域不同：**`typedef` 有作用域限定。`define` 不受作用域约束，只要是在`define` 声明后的引用 都是正确的。
- **对指针的操作不同**：`typedef` 和`define` 定义的指针时有很大的区别。

> `typedef` 定义是语句，因为句尾要加上分号。而`define` 不是语句，千万不能在句尾加分号。

## 25. 指针常量与常量指针区别

​	指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针 是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。

> 无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用 函数中的不可改变特性。

## 26. 简述队列和栈的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是 “后进先出”。

> 区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS 回收。分配方式类似于链表。它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。

## 27. 设置地址为0x67a9 的整型变量的值为0xaa6628. C语言的结构体和C++的有什么区别?

```cpp
int *ptr; 
ptr = (int *)0x67a9; 
*ptr = 0xaa66; 
```

> 这道题就是强制类型转换的典型例子，无论在什么平台地址长度和整型数据的长度是一样的， 即一个整型数据可以强制转换成地址指针类型，只要有意义即可。

## 29. 简述指针常量与常量指针的区别

- 指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。
- 指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。

> 无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。

## 30. 如何避免“野指针”?

- 指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向`NULL`。
- 指针p被`free`或者`delete`之后，没有置为`NULL`。解决办法：指针指向的内存空间被释放后指针应该指向`NULL`。
- 指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向`NULL`。

## 31. 句柄和指针的区别和联系是什么？

​	句柄和指针其实是两个截然不同的概念。Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32it的uint。指针则标记某个物理内存地址，两者是不同的概念。

## 32. 说一说extern“C”

​	extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern “C”就是其中的一个策略。

- C++代码调用C语言代码
- 在C++的头文件中使用
- 在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到

## 33. 对c++中的smart pointer四个智能指针：shared\_ptr,unique\_ptr,weak\_ptr,auto_ptr的理解

C++里面的四个智能指针: `auto_ptr`, `shared_ptr`, weak_ptr, `unique_ptr` 其中后三个是c++11支持，并且第一个已经被11弃用。

智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

- `auto_ptr`（c++98的方案，cpp11已经抛弃）

采用所有权模式。

```cpp
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr不会报错.
```

此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！

- `unique_ptr`（替换`auto_ptr`）

`unique_ptr`实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以`new`创建对象后因为发生异常而忘记调用delete”)特别有用。

采用所有权模式。

```cpp
unique_ptr<string> p3 (new string ("auto"));   //#4
unique_ptr<string> p4；                       //#5
p4 = p3;//此时会报错！！
```

编译器认为`p4=p3`非法，避免了p3不再指向有效数据的问题。因此，`unique_ptr`比`auto_ptr`更安全。

另外`unique_ptr`还有更聪明的地方：当程序试图将一个 `unique_ptr` 赋值给另一个时，如果源 `unique_ptr` 是个临时右值，编译器允许这么做；如果源 `unique_ptr` 将存在一段时间，编译器将禁止这么做，比如：

```cpp
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1;                                      // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
```

其中#1留下悬挂的`unique_ptr(pu1)`，这可能导致危害。而#2不会留下悬挂的`unique_ptr`，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，`unique_ptr` 优于允许两种赋值的`auto_ptr` 。

> 如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：

```cpp
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
cout << *ps2 << *ps1 << endl;
```

- `shared_ptr`

`shared_ptr`实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数`use_count`()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入`auto_ptr`, `unique_ptr`,`weak_ptr`来构造。当我们调用`release()`时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

`shared_ptr` 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。

成员函数：

`use_count` 返回引用计数的个数

`unique` 返回是否是独占所有权( use_count 为 1)

swap 交换两个 `shared_ptr` 对象(即交换所拥有的对象)

reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少

get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptrsp(new int(1)); sp 与 sp.get()是等价的

- `weak_ptr`

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

```cpp
class B;
class A
{
public:
shared_ptr<B> pb_;
~A()
{
     cout<<"A delete
";
}
};
class B
{
public:
shared_ptr<A> pa_;
~B()
{
    cout<<"B delete
";
}
};
void fun()
{
    shared_ptr<B> pb(new B());
    shared_ptr<A> pa(new A());
    pb->pa_ = pa;
    pa->pb_ = pb;
    cout<<pb.use_count()<<endl;
    cout<<pa.use_count()<<endl;
}
int main()
{
    fun();
    return 0;
}
```

可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。

> 不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();

## 34. C++的顶层const和底层const ？

- 底层const是代表对象本身是一个常量（不可改变）；
- 顶层const是代表指针的值是一个常量,而指针的值(即对象的地址)的内容可以改变（指向的不可改变）；

## 35. 拷贝初始化和直接初始化，初始化和赋值的区别?

- ClassTest ct1(“ab”); 这条语句属于直接初始化，它不需要调用复制构造函数，直接调用构造函数ClassTest(constchar *pc)，所以当复制构造函数变为私有时，它还是能直接执行的。
- ClassTest ct2 = “ab”; 这条语句为复制初始化，它首先调用构造函数 ClassTest(const char* pc) 函数创建一个临时对象，然后调用复制构造函数，把这个临时对象作为参数，构造对象ct2；所以当复制构造函数变为私有时，该语句不能编译通过。
- ClassTest ct3 = ct1;这条语句为复制初始化，因为 ct1 本来已经存在，所以不需要调用相关的构造函数，而直接调用复制构造函数，把它值复制给对象 ct3；所以当复制构造函数变为私有时，该语句不能编译通过。
- ClassTest ct4（ct1）;这条语句为直接初始化，因为 ct1 本来已经存在，直接调用复制构造函数，生成对象 ct3 的副本对象 ct4。所以当复制构造函数变为私有时，该语句不能编译通过。

> 要点就是拷贝初始化和直接初始化调用的构造函数是不一样的，但是当类进行复制时，类会自动生成一个临时的对象，然后再进行拷贝初始化。