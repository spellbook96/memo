# 绪论
## e.迭代与递归

### 1.算法设计思路  
* 分而治之：
    把大问题分解为小问题，逐个解决。最后合并问题。  
* 减而治之：
    用迭代的方法，每次迭代削减剩余问题的规模。
* 动态规划

> 递归方法计算整数数列之和  
```cpp
int sum(int A[], int n)
{
    return 
        (n<0)?
            0 : sum(A[n-1]) + A[n-1];
}
```

> 迭代方法计算整数数列之和
```cpp
int SumI(int A[], int n)
{
    int sum = 0; //O(1)
    for (int i =0; i < n; ++i)  //O(n)
    {
        sum += A[i]; //O(1)
    }
    return sum; //O(1)
}
```

### 2.复杂度分析
* 递归跟踪分析： //适用于简明的递推模式  
    检查每个递归实例累计所需时间（调用语句本身计入对应的子实例）其总和为计算法执行时间。

* 递推方程分析： //简洁抽象，适用于复杂的递归模式  

> 例：求解sum(A,n)所需时间  

递归方程： 
$$ 
T(n) = T(n-1) + O(1)\\
T(0)= O(1) \\
$$

### 3.经典问题  
> 任意数组A[0,n),将其前后颠倒。  
```
void reverse(int* A, int lo, int hi);
```

* 递归方法
```cpp
if (lo < hi)
{
    swap(A[lo],A[hi]);
    reserve(A, lo+1, hi-1);
}
else
    return;
```

* 迭代精简版
```cpp
while (lo < hi)
{
    swap(A[lo++],A[hi++]);
}
```